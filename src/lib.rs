#[cfg(windows)]
extern crate winapi;
use std::ffi::OsStr;
use std::io::Error;
use std::iter::once;
use std::os::windows::ffi::OsStrExt;
use std::ptr::null_mut;
use winapi::um::fileapi::{
    CreateFileW, GetFileSizeEx, ReadFile, WriteFile, CREATE_NEW, OPEN_EXISTING,
};
use winapi::um::handleapi::CloseHandle;
use winapi::um::winnt::{
    FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, GENERIC_READ, GENERIC_WRITE, HANDLE, LARGE_INTEGER,
};

use winapi::shared::minwindef::MAX_PATH;
use winapi::um::libloaderapi::GetModuleFileNameW;
// Use this to write file
#[cfg(windows)]
pub fn create_file(name: &str) -> Result<HANDLE, Error> {
    let wide_name: Vec<u16> = OsStr::new(name).encode_wide().chain(once(0)).collect();
    let file_handler = unsafe {
        CreateFileW(
            wide_name.as_ptr(),
            GENERIC_WRITE,
            FILE_SHARE_READ,
            null_mut(),
            CREATE_NEW,
            FILE_ATTRIBUTE_NORMAL,
            null_mut(),
        )
    };
    return Ok(file_handler);
}

#[cfg(windows)]
pub fn open_file(name: &str) -> Result<HANDLE, Error> {
    let wide_name: Vec<u16> = OsStr::new(name).encode_wide().chain(once(0)).collect();
    let file_handler = unsafe {
        CreateFileW(
            wide_name.as_ptr(),    // file to open
            GENERIC_READ,          // open for reading
            FILE_SHARE_READ,       // share for reading
            null_mut(),            // default security
            OPEN_EXISTING,         // existing file only
            FILE_ATTRIBUTE_NORMAL, // normal file
            null_mut(),            // no attr. template
        )
    };
    return Ok(file_handler);
}

#[cfg(windows)]
pub fn write_file(file_handler: HANDLE, buffer: Vec<u8>) -> Result<u32, Error> {
    let mut byte_written = 0u32;
    unsafe {
        WriteFile(
            file_handler,
            buffer.as_ptr() as *const winapi::ctypes::c_void,
            (buffer.len()) as u32,
            &mut byte_written,
            null_mut(),
        );
    }
    return Ok(byte_written);
}

#[cfg(windows)]
pub fn read_file(file_handler: HANDLE, buffer: &mut [u8]) -> Result<u32, Error> {
    let byte_read = 0u32;
    unsafe {
        ReadFile(
            file_handler,
            buffer.as_ptr() as *mut winapi::ctypes::c_void,
            get_file_size(file_handler).unwrap() as u32,
            &byte_read as *const _ as *mut u32,
            null_mut(),
        )
    };
    Ok(byte_read)
}

#[cfg(windows)]
pub fn close_handle(file_handler: HANDLE) -> Result<i32, Error> {
    Ok(unsafe { CloseHandle(file_handler) })
}

#[cfg(windows)]
pub fn get_file_size(file_handler: HANDLE) -> Result<i64, Error> {
    let size = 0i64;
    unsafe {
        GetFileSizeEx(file_handler, &size as *const _ as *mut LARGE_INTEGER);
    };
    return Ok(size.clone());
}

// Get the current path of the running malware. Run this if the malware is on the same process.
#[cfg(windows)]
pub fn get_current_path() -> Result<Vec<u16>, Error> {
    let buffer = [0u16; MAX_PATH];
    let length =
        unsafe { GetModuleFileNameW(null_mut(), &buffer as *const _ as *mut u16, MAX_PATH as u32) };
    let mut result: Vec<u16> = Vec::new();
    for wchar in buffer[..length as usize].iter() {
        result.push(wchar.clone());
    }
    Ok(result)
}
